function New-ApplicationHelper {
    param
    (
        [Parameter(Mandatory = $true)]
        [string]
        $AppName,
        [Parameter(Mandatory = $true)]
        [string]
        $rootApplicationPath,
        [Parameter(Mandatory = $true)]
        [string]
        #todo validate path
        $SCCMFolderPath,
        [Parameter(Mandatory = $true)]
        [string]
        $Publisher,
        [Parameter(Mandatory = $false)]
        [string]
        $Icon,
        [Parameter(Mandatory = $false)]
        [int]
        $EstimatedRuntimeMins = 15,
        [Parameter(Mandatory = $false)]
        [int]
        $MaximumRuntimeMins = 30,
        [Parameter(Mandatory = $false)]
        [string]
        $Language = "English",
        [Parameter(Mandatory = $true)]
        [string]
        $DP_Group,
        [Parameter(Mandatory = $true)]
        [string]
        [ValidateSet('FileSystem', 'Registry', 'WindowsInstaller', 'PowershellScript', IgnoreCase = $true)]
        $DetectionMethod

    )

    # Get-ChildItem has trouble working with UNC paths from the $SCCM_Site: drive. That is why I map a $SCCM_Share_Letter drive
    $count = (Measure-Object -InputObject $SCCM_Share -Character).Characters + 1
    # Gets the most recent folder for a given app
    $AppPath = "$($SCCM_Share_Letter):\" + $rootApplicationPath.Substring($count) | Get-ChildItem | Where-Object { $_.Name -match $SCCM_SourceFolderRegex } | Sort-Object -Property CreationTime -Descending | Select-Object -First 1
    # Each app folder is named like 'AppName Version (R#). So this line just selects Version R#
    $AppVersion = $AppPath.Name -split ' ' | Select-Object -Last 2
    # Transform the app path back to a full unc path withouth a drive letter
    $AppPath = "$SCCM_Share" + ($AppPath.FullName).Substring(2)
    $AppNameFull = "$AppName $appVersion"

    $alreadyExists = Get-CMApplication -Name $AppNameFull
    while ($alreadyExists) {
        #if the package name already exists increments R#
        Write-Output "$AppNameFull already exists in SCCM, auto incrementing the R`#"
        #This line is overly complex, but it works. I couldn't think of a better way to write it.
        $AppNameFull = $AppNameFull.Substring(0, $AppNameFull.Length - 2) + ([int]$AppNameFull.Substring($AppNameFull.Length - 2, 1) + 1) + ")"
        $alreadyExists = Get-CMApplication -Name $AppNameFull
    }

    try {
        $Application = New-CMApplication -Name "$AppNameFull" -Publisher "$Publisher" -IconLocationFile "$Icon" -IsFeatured $false -AutoInstall $True -LocalizedName "$AppNameFull"
        #$Application = New-CMApplication -Name "Application01" -Description "New Application" -Publisher "Contoso" -SoftwareVersion 1.0.0.1 -OptionalReference "Reference" -ReleaseDate 2/24/2016 -AutoInstall $True -Owner "Administrator" -SupportContact "Administrator" -LocalizedName "Application01" -UserDocumentation "https://contoso.com/content" -LinkText "For more information, see https://contoso.com/content" -LocalizedDescription "New Localized Application" -Keyword "application" -PrivacyUrl "https://contoso.com/library/privacy" -IsFeatured $True -IconLocationFile "C:\Users\administrator\Desktop\icon.png" -DisplaySupersedenceInApplicationCatalog $True
        Write-Output "$AppNameFull created in SCCM"
    }
    catch [exception] {
        Write-Output "Failed to create Application $AppNameFull."
        Write-Output "$_"
        Set-Location "c:"
        break
    }

    try {
        $DeploymentTypeOutput

        $parameters = @{
            ApplicationName = "$AppNameFull" 
            DeploymentTypeName = "Script $AppNameFull"
            Comment = "Generated by powershell module"
            InstallCommand = "Deploy-Application.exe"
            ContentLocation = "$appPath"
            EstimatedRuntimeMins = "$EstimatedRuntimeMins"
            MaximumRuntimeMins = "$MaximumRuntimeMins"
            InstallationBehaviorType = "InstallForSystem"
            LogonRequirementType = "WhetherOrNotUserLoggedOn"
            UserInteractionMode = "Hidden"
            CacheContent = $true
            ContentFallback = $true
            UninstallCommand = "Deploy-Application.exe -DeploymentType Uninstall"
        }
        switch ($DetectionMethod) {
            "PowershellScript" { 
                $parameters += @{
                    ScriptLanguage = "PowerShell"
                    ScriptFile = "$appPath\SupportFiles\SCCMApplicationDetection.ps1"
                }

                $DeploymentTypeOutput = Add-CMScriptDeploymentType @parameters
            }
            "WindowsInstaller" {
                #cd to c: to get around GetChildItem issue 
                # https://stackoverflow.com/questions/23574653/running-get-childitem-on-unc-path-works-in-powershell-but-not-in-powershell-run
                Push-Location
                Set-Location "C:"
                $MSIS = Get-ChildItem -Path "$appPath\Files"
                $MSIS = $MSIS.FullName -like "*.msi"
                Pop-Location
                $DetectionClauses = @()
                foreach ($MSI in $MSIS) {
                    $ProductCodeString = Get-MSIFileInformation -Path "$MSI" -Property ProductCode
                    $ProductCodeGUID = [System.guid]::New($ProductCodeString)
                    $Clause = New-CMDetectionClauseWindowsInstaller -Existence -ProductCode $ProductCodeGUID
                    $DetectionClauses += $Clause
                }


                $parameters += @{
                    AddDetectionClause = $DetectionClauses
                }
                
                if ($DetectionClauses.count -gt 1){
                    $DetectionClauseConnector = @()
                    For ($i=1; $i -lt $DetectionClauses.length; $i++) {
                        $logicName = $DetectionClauses[$i].Setting.LogicalName
                        $DetectionClauseConnector += @{"LogicalName"= $logicName;Connector="OR"}
                    }
                    $parameters['DetectionClauseConnector'] = $DetectionClauseConnector
                }

                $DeploymentTypeOutput = Add-CMScriptDeploymentType @parameters
            }
            "Registry" {  }
            "FileSystem" {  }
            Default { Write-Error "No DetectionMethod specified"}
        }

        Write-Output "Deployment made 'Install $app Silent'"
    }
    catch [exception] {
        Write-Output "Failed to create Deployment Type for $AppNameFull."
        Write-Output "$_"
        Set-Location "c:"
        break
    }

    try {
        Start-CMContentDistribution -ApplicationName  "$AppNameFull" -DistributionPointGroupName "$DistributionPointGroupName"
        Write-Output "Application Distribution to $DistributionPointGroupName started"
    }
    catch [exception] {
        Write-Output "Failed to Distribute $AppNameFull to $DistributionPointGroupName"
        Write-Output "$_"
        Set-Location "c:"
        break
    }

    try {
        Move-CMObject -FolderPath "$SCCMFolderPath" -InputObject $Application
        Write-Output "Moved $AppNameFull to $SCCMFolderPath"
    }
    catch [exception] {
        Write-Output "Failed to moved $AppNameFull to $SCCMFolderPath"
        Write-Output "$_"
        Set-Location "c:"
        break
    }
    try {
        Deploy-ApplicationToSCCMCollection -ApplicationName $AppNameFull -Collection "$TestCollection"
    }
    catch [exception] {
        Write-Output "$_"
        Set-Location "c:"
        break
    }
}