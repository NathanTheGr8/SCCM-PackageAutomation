function New-ApplicationHelper {
    param
    (
        [Parameter(Mandatory = $true)]
        [string]
        $AppName,
        [Parameter(Mandatory = $true)]
        [string]
        $rootApplicationPath,
        [Parameter(Mandatory = $true)]
        [string]
        [ValidateSet('HomeOffice', 'CoreApps','Misc', IgnoreCase = $true)]
        $SCCMFolder,
        [Parameter(Mandatory = $true)]
        [string]
        $Publisher,
        [Parameter(Mandatory = $false)]
        [int]
        $Duration = 20
    )
    switch ($SCCMFolder) {
        "HomeOffice" {
            $SCCMFolderPath = "$($SCCM_Site):\$($SCCMAppFolders.HomeOffice.QA)"
        }
        "CoreApps" {
            $SCCMFolderPath = "$($SCCM_Site):\$($SCCMAppFolders.CoreApps.QA)"
        }
        "Misc" {
            $SCCMFolderPath = "$($SCCM_Site):\$($SCCMAppFolders.Misc.QA)"
        }
    }

    # Get-ChildItem has trouble working with UNC paths from the $SCCM_Site: drive. That is why I map a $SCCM_Share_Letter drive
    $count = (Measure-Object -InputObject $SCCM_Share -Character).Characters + 1
    # Gets the most recent folder for a given app
    $AppPath =  "$($SCCM_Share_Letter):\" + $rootApplicationPath.Substring($count) | Get-ChildItem | Sort-Object -Property CreationTime -Descending | Select-Object -First 1
    # Each app folder is named like 'AppName Version (R#). So this line just selects Version R#
    $AppVersion = $AppPath.Name -split ' ' | Select-Object -Last 2
    # Transform the app path back to a full unc path withouth a drive letter
    $AppPath = "$SCCM_Share"+($AppPath.FullName).Substring(2)
    $AppNameFull = "$AppName $appVersion"

    $alreadyExists = Get-CMApplication -Name $AppNameFull
    while ($alreadyExists){
        #if the package name already exists increments R#
        Write-Output "$AppNameFull already exists in SCCM, auto incrementing the R`#"
        #This line is overly complex, but it works. I couldn't think of a better way to write it.
        $AppNameFull = $AppNameFull.Substring(0,$AppNameFull.Length - 2) + ([int]$AppNameFull.Substring($AppNameFull.Length - 2,1)+1)+ ")"
        $alreadyExists = Get-CMApplication -Name $AppNameFull
    }

    try {
        $Application = New-CMApplication -Name "$AppNameFull" -Path "$appPath" -Publisher "$Publisher" -IconLocationFile "$home\downloads\chrome.png" -DisplaySupersedenceInApplicationCatalog $True -IsFeatured $false -AutoInstall $True -Keyword "browser" -SoftwareVersion 1.0.0.1 -LocalizedName "$AppNameFull"
        #$Application = New-CMApplication -Name "Application01" -Description "New Application" -Publisher "Contoso" -SoftwareVersion 1.0.0.1 -OptionalReference "Reference" -ReleaseDate 2/24/2016 -AutoInstall $True -Owner "Administrator" -SupportContact "Administrator" -LocalizedName "Application01" -UserDocumentation "https://contoso.com/content" -LinkText "For more information, see https://contoso.com/content" -LocalizedDescription "New Localized Application" -Keyword "application" -PrivacyUrl "https://contoso.com/library/privacy" -IsFeatured $True -IconLocationFile "C:\Users\administrator\Desktop\icon.png" -DisplaySupersedenceInApplicationCatalog $True
        Write-Output "$AppNameFull created in SCCM"
    }
    catch [exception]{
        Write-Output "$_"
        break
    }

    try {
        $DeploymentTypeOutput = Add-CMScriptDeploymentType -ApplicationName "$AppNameFull" -DeploymentTypeName "$AppNameFull" `
        -Comment "Generated by powershell module" -InstallCommand 'msiexec /i ""\\Machine01\Resources\Applications\MSI\AdvertMSI\AdvertMSI.msi"' `
        -ScriptLanguage VBScript -ScriptContent "1231231" -ForceScriptDetection32Bit

        $ProgramOutput = New-CMApplicationDeployment -Name "$AppNameFull" -DeployAction Install -StandardProgramName "Install $app Silent" -CommandLine "Deploy-Application.exe" -RunType Hidden -RunMode RunWithAdministrativeRights -ProgramRunType WhetherOrNotUserIsLoggedOn -Duration $Duration -UserInteraction $false
        #-Name 'Vendor Program Version' -DeployAction Install -CollectionName 'Collection Name Here' -DeployPurpose Required -DistributeContent "\Application\Path_to_Application"
        Write-Output "Program made 'Install $app Silent'"
    }
    catch [exception]{
        Write-Output "$_"
        break
    }

    try {
        if ($MaintainedApp.AWSDistributionApp){
            Start-CMContentDistribution -ApplicationName  "$AppNameFull" -DistributionPointGroupName "All Distribution Points"
            Start-CMContentDistribution -ApplicationName  "$AppNameFull" -DistributionPointGroupName "AWS"
            Write-Output "Package Distribution to all DP and AWS started"
        }
        else {
            Start-CMContentDistribution -ApplicationName  "$AppNameFull" -DistributionPointGroupName "All Distribution Points"
            Write-Output "Package Distribution to all DP started"
        }
    }
    catch [exception]{
        Write-Output "$_"
        break
    }

    try {
        Move-CMObject -FolderPath "$SCCMFolderPath" -InputObject $Application
        Write-Output "Moved $AppNameFull to $SCCMFolderPath"
    }
    catch [exception]{
        Write-Output "$_"
        break
    }
    #todo
    # try {
    #     Deploy-ToSCCMCollection -PackageName $AppNameFull -Collection "$TestCollection"
    #     Write-Output "Deployed $AppNameFull to $TestCollection"
    # }
    # catch [exception]{
    #     Write-Output "$_"
    #     break
    # }
}